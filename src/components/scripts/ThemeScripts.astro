<!-- Theme Scripts -->
<script async defer>
	document.addEventListener('astro:page-load', () => {
		// Menu Dropdown
		const menuItems = document.querySelectorAll('.header__menu-item')
		menuItems.forEach((menuItem) => {
			const submenu = menuItem.querySelector('.header__submenu')
			const link = menuItem.querySelector('.header__menu-link')

			if (submenu && link) {
				link.addEventListener('click', function (event) {
					event.preventDefault()
					menuItem.classList.toggle('open')
				})
			}
		})
		document.addEventListener('click', function (event) {
			const target = event.target

			menuItems.forEach((menuItem) => {
				const submenu = menuItem.querySelector('.header__submenu')
				if (submenu && !menuItem.contains(target)) {
					menuItem.classList.remove('open')
				}
			})
		})

		// Menu toggle
		const headerToggle = document.querySelector('.header__toggle')
		const headerMenu = document.querySelector('.header__menu')
		if (headerToggle && headerMenu) {
			headerToggle.addEventListener('click', () => {
				headerToggle.classList.toggle('toggle--open')
				const isExpanded = headerToggle.getAttribute('aria-expanded') === 'true'
				const newExpandedValue = isExpanded ? 'false' : 'true'
				headerToggle.setAttribute('aria-expanded', newExpandedValue)
				headerMenu.classList.toggle('menu--open')
			})
		}

		// Modals
		function openModal(modal) {
			if (modal && modal.classList.contains('modal')) {
				modal.classList.add('open')
			}
		}
		function closeModal(modal) {
			if (modal && modal.classList.contains('modal')) {
				modal.classList.remove('open')
			}
		}
		const modalButtons = document.querySelectorAll('[data-modal]')

		modalButtons.forEach(function (button) {
			button.addEventListener('click', function (event) {
				event.preventDefault()
				const modalId = button.getAttribute('data-modal')
				const modal = document.getElementById(modalId)
				openModal(modal)
			})
		})
		document.querySelectorAll('.modal').forEach(function (modal) {
			modal.addEventListener('click', function (event) {
				if (event.target === modal) {
					closeModal(modal)
				}
			})
			const close = modal.querySelector('.modal__close')
			close.addEventListener('click', function (event) {
				event.stopPropagation()
				closeModal(modal)
			})
		})
	})
</script>

<!-- Light/Dark mode  -->
<script>
	const applyTheme = () => {
		// Temporarily disable transitions
		document.documentElement.classList.add('disable-transitions')

		const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
		const storedTheme = localStorage.getItem('theme')

		if (storedTheme === 'dark') {
			document.documentElement.classList.add('dark')
		} else if (storedTheme === 'light') {
			document.documentElement.classList.remove('dark')
		} else {
			if (systemPrefersDark) {
				document.documentElement.classList.add('dark')
			} else {
				document.documentElement.classList.remove('dark')
			}
		}

		// Allow transitions again shortly after
		window.requestAnimationFrame(() => {
			setTimeout(() => {
				document.documentElement.classList.remove('disable-transitions')
			}, 0)
		})
	}

	const setupAutoThemeListener = () => {
		const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
		const storedTheme = localStorage.getItem('theme')
		if (!storedTheme || storedTheme === 'auto') {
			mediaQuery.addEventListener('change', applyTheme)
		}
	}

	const setupThemeSwitcher = () => {
		const themeSwitcher = document.getElementById('theme-selector')

		if (themeSwitcher) {
			themeSwitcher.addEventListener('click', () => {
				const currentEffectiveTheme = document.documentElement.classList.contains('dark')
					? 'dark'
					: 'light'
				const stored = localStorage.getItem('theme') || 'auto'

				let next = 'auto' // default fallback

				if (stored === 'auto') {
					next = currentEffectiveTheme === 'dark' ? 'light' : 'dark'
				} else if (stored === 'dark') {
					next = 'light'
				} else if (stored === 'light') {
					next = 'auto'
				}

				if (typeof next === 'string') {
					localStorage.setItem('theme', next)
					applyTheme()
				}
			})
		}
	}

	const initTheme = () => {
		// Forced modes via fallback classes
		if (document.documentElement.classList.contains('mode-dark')) {
			document.documentElement.classList.add('dark')
			return
		}
		if (document.documentElement.classList.contains('mode-light')) {
			document.documentElement.classList.remove('dark')
			return
		}

		// Auto or stored theme
		applyTheme()
		setupAutoThemeListener()
		setupThemeSwitcher()
	}

	// Run once
	initTheme()
	// Re-run on Astro transitions
	document.addEventListener('astro:page-loaded', initTheme)
	document.addEventListener('astro:after-swap', initTheme)
</script>

<!-- Scroll animations -->
<script>
	const initializeScrollAnimationsAndCounters = () => {
		const observer = new IntersectionObserver(
			(entries) => {
				entries.forEach((entry) => {
					if (entry.isIntersecting) {
						const el = entry.target

						// Scroll-in animation
						if (el.classList.contains('col') && el.closest('.scroll-animation')) {
							el.classList.add('scroll-animated')
						}

						// Counter animation
						if (el.classList.contains('counter') && el instanceof HTMLElement) {
							const target = parseInt(el.dataset.target || '0', 10)
							const suffix = el.dataset.suffix || ''

							let current = 0
							const duration = 1000
							const increment = target / (duration / 16)

							const updateCounter = () => {
								current += increment
								if (current >= target) {
									el.textContent = target + suffix
								} else {
									el.textContent = Math.floor(current) + suffix
									requestAnimationFrame(updateCounter)
								}
							}

							updateCounter()
							observer.unobserve(el)
						}
					}
				})
			},
			{ threshold: 0.2 }
		)

		document
			.querySelectorAll('.scroll-animation .col:not(.no-scroll-animation)')
			.forEach((el) => observer.observe(el))

		document.querySelectorAll('.counter').forEach((el) => observer.observe(el))
	}

	const initializeParallax = () => {
		const parallaxElements = document.querySelectorAll('.card__media--parallax > *, .parallax > *')
		let ticking = false

		const updateParallax = () => {
			const scrollTop = window.pageYOffset
			const windowHeight = window.innerHeight

			parallaxElements.forEach((el) => {
				if (!(el instanceof HTMLElement)) return

				const rect = el.getBoundingClientRect()
				const offset = rect.top + window.pageYOffset
				const height = el.offsetHeight

				if (offset + height > scrollTop && offset < scrollTop + windowHeight) {
					const percent = (scrollTop + windowHeight - offset) / (windowHeight + height)
					const translateY = Math.min(Math.max(percent * 100 - 50, -50), 50)
					el.style.transform = `translateY(${translateY}px)`
				}
			})

			ticking = false
		}

		const onScroll = () => {
			if (!ticking) {
				requestAnimationFrame(updateParallax)
				ticking = true
			}
		}

		window.addEventListener('scroll', onScroll)
		window.addEventListener('resize', onScroll)
		onScroll()
	}

	const init = () => {
		initializeScrollAnimationsAndCounters()
		initializeParallax()
	}

	document.addEventListener('DOMContentLoaded', init)
	document.addEventListener('astro:page-loaded', init)
	document.addEventListener('astro:after-swap', init)
</script>

<!-- Video -->
<script>
	function fixFirefoxVideoResume() {
		const videos = document.querySelectorAll('.video-in-viewport')

		videos.forEach((video) => {
			if (!(video instanceof HTMLVideoElement)) return

			// Re-assign source to force reload (fixes some Firefox bugs)
			const source = video.querySelector('source')
			if (source) {
				video.load() // re-load the video element
			}

			// Play if autoplay is true
			if (video.autoplay && video.paused) {
				video.play().catch(() => {})
			}
		})
	}

	document.addEventListener('astro:after-swap', fixFirefoxVideoResume)
	document.addEventListener('astro:page-loaded', fixFirefoxVideoResume)
</script>
